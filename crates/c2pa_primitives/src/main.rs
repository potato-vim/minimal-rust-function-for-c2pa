//! C2PA Primitives - Essential Demos
//!
//! Run with: cargo run

use c2pa_primitives::*;

fn main() -> Result<(), TransformError> {
    println!("C2PA Primitives: Type-Safe Provenance\n");

    demo_chain()?;
    demo_verified_gate()?;
    demo_redaction()?;
    demo_graph()?;

    println!("\n========== Macro-based Transforms ==========\n");
    demo_macro_basic()?;
    demo_macro_with_params()?;

    Ok(())
}

// ============================================================================
// Macro-based transforms (Phase 0 & 1)
// ============================================================================

/// Phase 0: Basic transform - fn(&T) -> U
#[c2pa_transform(name = "double", relationship = "derivedFrom")]
fn double(x: &u32) -> u32 {
    x * 2
}

/// Phase 0: Another basic transform
#[c2pa_transform(name = "add_ten")]
fn add_ten(x: &u32) -> u32 {
    x + 10
}

/// A simple mask type for demo
#[derive(Debug, Clone)]
pub struct Mask {
    pub x: u32,
    pub y: u32,
    pub w: u32,
    pub h: u32,
}

/// Phase 1: Transform with recorded parameter (mask commit, NOT raw value)
#[c2pa_transform(name = "redact_macro", relationship = "derivedFrom", record(params(mask)))]
fn redact_with_mask(img: &Image, mask: Mask) -> Image {
    let mut output = img.clone();
    for dy in 0..mask.h {
        for dx in 0..mask.w {
            output.set(mask.x + dx, mask.y + dy, 0);
        }
    }
    output
}

/// Demo: Basic macro transforms (Phase 0)
fn demo_macro_basic() -> Result<(), TransformError> {
    println!("═══ Demo 4: Macro Transform (Phase 0) ═══");
    println!("Shows: #[c2pa_transform] generates wrapper functions\n");

    // Create source
    let source: C2pa<u32, Verified> = C2paBuilder::new(5u32)
        .generator("demo/1.0")
        .sign(&TestSigner)?;

    println!("1. Source value: {}", source.payload());

    // Use macro-generated wrappers
    let mut ctx = TransformContext::new("demo/1.0");

    // double_c2pa is auto-generated by #[c2pa_transform]
    let doubled = double_c2pa(&source, &mut ctx)?;
    println!("2. After double_c2pa: {} (= 5 * 2)", doubled.payload());
    println!("   ingredients: {}", doubled.provenance().ingredients.len());

    // Chain it
    ctx.clear_transform_metadata();
    let result = add_ten_c2pa(&doubled, &mut ctx)?;
    println!("3. After add_ten_c2pa: {} (= 10 + 10)", result.payload());
    println!("   ingredients: {}", result.provenance().ingredients.len());

    // Verify provenance chain
    println!("\n   Provenance chain:");
    println!("   source claim_hash: {:02x}{:02x}...",
             source.provenance().claim_hash.0[0],
             source.provenance().claim_hash.0[1]);
    println!("   doubled references: {:02x}{:02x}...",
             doubled.provenance().ingredients[0].claim_hash.0[0],
             doubled.provenance().ingredients[0].claim_hash.0[1]);
    println!("   result references: {:02x}{:02x}...",
             result.provenance().ingredients[0].claim_hash.0[0],
             result.provenance().ingredients[0].claim_hash.0[1]);
    println!();

    Ok(())
}

/// Demo: Transform with parameter commits (Phase 1)
fn demo_macro_with_params() -> Result<(), TransformError> {
    println!("═══ Demo 5: Macro Transform with Params (Phase 1) ═══");
    println!("Shows: record(params(mask)) commits hash, NOT raw value\n");

    // Create source image
    let source_img = Image::test_pattern(8, 4);
    let source: C2pa<Image, Verified> = C2paBuilder::new(source_img)
        .generator("camera/1.0")
        .sign(&TestSigner)?;

    println!("1. Source image:");
    print_image(source.payload());

    // Create mask
    let mask = Mask { x: 2, y: 1, w: 4, h: 2 };
    println!("2. Mask: {:?}", mask);

    // Use macro-generated wrapper with param commit
    let mut ctx = TransformContext::new("editor/1.0");
    let redacted = redact_with_mask_c2pa(&source, mask.clone(), &mut ctx)?;

    println!("3. After redact_with_mask_c2pa:");
    print_image(redacted.payload());

    println!("4. Provenance (mask param is committed, NOT stored raw):");
    println!("   ingredients: {}", redacted.provenance().ingredients.len());
    println!("   transform_name: {:?}", ctx.transform_name);
    println!("   param_commits: {} entry (hash only, no raw value)",
             ctx.param_commits.len());

    if let Some((name, hash)) = ctx.param_commits.first() {
        println!("   - '{}' commit: {:02x}{:02x}{:02x}{:02x}...",
                 name, hash[0], hash[1], hash[2], hash[3]);
        println!("   - Raw mask value {:?} is NOT in provenance!", mask);
    }

    println!("\n   This ensures PII/secrets don't leak into provenance.");
    println!();

    Ok(())
}

/// Existing demo: Chain of transforms (A → B → C)
fn demo_chain() -> Result<(), TransformError> {
    println!("═══ Demo 0: Provenance Chain ═══");
    println!("Shows: Verified → transform → Verified with parent tracking\n");

    let source: C2pa<u32, Verified> = C2paBuilder::new(10u32)
        .generator("demo/1.0")
        .sign(&TestSigner)?;

    let double = FnTransform::new(|x: &u32| x * 2, "double");
    let add_ten = FnTransform::new(|x: &u32| x + 10, "add_ten");
    let mut ctx = TransformContext::new("demo/1.0");

    let step1 = double.transform(&source, &mut ctx)?;
    let step2 = add_ten.transform(&step1, &mut ctx)?;

    println!("Chain: {} → {} → {}", source.payload(), step1.payload(), step2.payload());
    println!("Each step has 1 ingredient (parent):");
    println!("  step1.ingredients.len() = {}", step1.provenance().ingredients.len());
    println!("  step2.ingredients.len() = {}", step2.provenance().ingredients.len());
    println!();

    Ok(())
}

/// Demo 1: Verified Gate - Unverified bytes cannot be parsed
fn demo_verified_gate() -> Result<(), TransformError> {
    println!("═══ Demo 1: Verified Gate (Parse) ═══");
    println!("Shows: Unverified bytes → verify() → Verified bytes → parse → Invoice\n");

    // Simulate external input (e.g., from network)
    let raw_bytes = b"42:1000".to_vec();
    let content_hash = ContentHash::compute(&raw_bytes);

    // Create "unverified" wrapper (simulating received data with manifest)
    let claim_hash = {
        use sha2::{Digest, Sha256};
        let mut h = Sha256::new();
        h.update(b"external-source");
        h.update(&content_hash.0);
        ClaimHash(h.finalize().into())
    };

    let unverified: C2pa<Vec<u8>, Unverified> = C2pa::new(
        raw_bytes,
        Provenance::root(
            "urn:uuid:external-source",
            claim_hash.clone(),
            AssetBinding::Hash(content_hash),
        ),
    );

    println!("1. Received unverified bytes: {:?}",
             String::from_utf8_lossy(unverified.payload()));

    // This would NOT compile:
    // let parse = ParseTransform::<Invoice>::new();
    // parse.transform(&unverified, &mut ctx);  // ERROR: expected Verified

    println!("2. Cannot parse directly (compile error if tried)");

    // Must verify first
    let verified: C2pa<Vec<u8>, Verified> = verify(unverified, &claim_hash)?;
    println!("3. After verify(): now Verified");

    // Now we can parse
    let parse = ParseTransform::<Invoice>::new();
    let mut ctx = TransformContext::new("demo/1.0");
    let invoice: C2pa<Invoice, Verified> = parse.transform(&verified, &mut ctx)?;

    println!("4. Parsed invoice: {:?}", invoice.payload());
    println!("   Provenance: {} ingredient(s), relationship: {}",
             invoice.provenance().ingredients.len(),
             invoice.provenance().ingredients[0].relationship.as_str());
    println!();

    Ok(())
}

/// Demo 2: Redaction - Derived content maintains provenance
fn demo_redaction() -> Result<(), TransformError> {
    println!("═══ Demo 2: Redaction (Derivative) ═══");
    println!("Shows: Image → redact region → new Image with derivedFrom\n");

    // Create source image
    let source_img = Image::test_pattern(8, 4);
    let source: C2pa<Image, Verified> = C2paBuilder::new(source_img)
        .generator("camera/1.0")
        .sign(&TestSigner)?;

    println!("1. Source image: {}x{}", source.payload().width, source.payload().height);
    print_image(source.payload());

    // Redact region (2,1) to (5,2)
    let redact = RedactTransform::new(2, 1, 4, 2);
    let mut ctx = TransformContext::new("editor/1.0");
    let redacted: C2pa<Image, Verified> = redact.transform(&source, &mut ctx)?;

    println!("2. After redact(2,1,4,2):");
    print_image(redacted.payload());

    println!("3. Provenance preserved:");
    println!("   ingredients.len() = {}", redacted.provenance().ingredients.len());
    println!("   relationship = {}",
             redacted.provenance().ingredients[0].relationship.as_str());
    println!("   source hash = {:02x}{:02x}...",
             source.provenance().claim_hash.0[0],
             source.provenance().claim_hash.0[1]);
    println!("   ingredient hash = {:02x}{:02x}...",
             redacted.provenance().ingredients[0].claim_hash.0[0],
             redacted.provenance().ingredients[0].claim_hash.0[1]);
    println!();

    Ok(())
}

/// Demo 3: Graph - Multiple sources create DAG provenance
fn demo_graph() -> Result<(), TransformError> {
    println!("═══ Demo 3: Graph (DAG Provenance) ═══");
    println!("Shows: Image A + Image B → composite → new Image with 2 ingredients\n");

    // Create two independent source images
    let img_a = Image::new(4, 3, 0xAA);
    let img_b = Image::new(4, 3, 0x55);

    let source_a: C2pa<Image, Verified> = C2paBuilder::new(img_a)
        .generator("camera-a/1.0")
        .sign(&TestSigner)?;

    let source_b: C2pa<Image, Verified> = C2paBuilder::new(img_b)
        .generator("camera-b/1.0")
        .sign(&TestSigner)?;

    println!("1. Source A (4x3, fill=0xAA):");
    print_image(source_a.payload());

    println!("2. Source B (4x3, fill=0x55):");
    print_image(source_b.payload());

    // Compose: horizontal concatenation
    let concat = HConcatTransform;
    let mut ctx = TransformContext::new("compositor/1.0");
    let composite: C2pa<Image, Verified> = concat.compose(&source_a, &source_b, &mut ctx)?;

    println!("3. Composite (A | B):");
    print_image(composite.payload());

    println!("4. DAG Provenance:");
    println!("   ingredients.len() = {} (not 1, but 2!)",
             composite.provenance().ingredients.len());

    for (i, ing) in composite.provenance().ingredients.iter().enumerate() {
        println!("   [{}] {} → {:02x}{:02x}...",
                 i,
                 ing.relationship.as_str(),
                 ing.claim_hash.0[0],
                 ing.claim_hash.0[1]);
    }

    println!("\n   This is a DAG, not a chain:");
    println!("       A ─┐");
    println!("          ├─→ Composite");
    println!("       B ─┘");
    println!();

    Ok(())
}

/// Helper: print image as ASCII
fn print_image(img: &Image) {
    for y in 0..img.height {
        print!("   ");
        for x in 0..img.width {
            let v = img.get(x, y).unwrap_or(0);
            let c = if v == 0 { '░' } else if v < 0x80 { '▒' } else { '█' };
            print!("{}", c);
        }
        println!();
    }
}
